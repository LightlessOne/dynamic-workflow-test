name: _Execute_Image_Module

on:
  workflow_call:
    inputs:
      stage_id:
        required: true
        type: string
      job_id:
        required: true
        type: string
      module_image:
        required: true
        type: string
      module_command:
        required: true
        type: string
      input:
        required: false
        type: string
      output:
        required: false
        type: string

env:
  GITHUB_MODULES_OPS_URL: https://github.com/LightlessOne/Quber-CLI/releases/latest/download/github_modules_ops.pyz
  #GITHUB_MODULES_OPS_URL: https://github.com/LightlessOne/Quber-CLI/releases/download/v0.0.1/github_modules_ops.pyz

jobs:
  execute-module-command:
    runs-on: ubuntu-latest
    container:
      image: ${{ inputs.module_image }}
    env:
      input: ${{ inputs.input }}
      output: ${{ inputs.output }}
      CI_JOB_NAME: ${{ inputs.job_id }}
      CI_JOB_STAGE: ${{ inputs.stage_id }}
    steps:
      - name: Download files
        id: download-files
        uses: actions/download-artifact@v4
        with:
          path: rt/stored_data
          merge-multiple: true

### Possible solution for WHEN resolving:
# generator just adds when as string-formatted-yaml (same as input/output) (and all jobs have 'continue-on-error=true')
# prepare - prepares data, resolves 'when' to env var (like env.NEEDS_TO_EXECUTE in $GITHUB_ENV)
# execute step has 'continue-on-error' (so 'store' always happens, and it needs to know previous step failed somehow) and 'if: env.NEEDS_TO_EXECUTE'
# store-data saves 'job' status
#   so next to 'params.yaml' we'll have 'status.yaml' with 'status: SUCCESS/FAILURE/SKIPPED'

### But then we'll always fetch image, start subflow etc. for each possible job
# which is not optimal for cases like
#   condition: APP_NAME.toLowerCase() in ['cow', 'decoco', 'ssm', 'composite-status-metrics-producer', 'env-checker', 'log-exporter' ]
# another possible solution: resolving 'when.condition' at Generator stage, and just not creating skipped jobs
# we'll still have to check 'when.statuses' during execution - or do we??
# generate jobs with ["if: always()" or "if: success() || failure()"] - if they have FAILURE in their statuses?

### Second options looks way simpler and more predictable

### As for resolving groovy when.condition:
# 1. we'll need to transform conditions from groovy to python somehow first (so we def wont support everything, only basic stuff)
#    looks like a complex lexical-parser, probably too much
# 2. Just using groovy binaries (pass it expression and context)

      - name: Execute Module
        id: execute-module-command
        run: |
          wget -O /usr/quber/github_modules_ops.pyz $GITHUB_MODULES_OPS_URL
          unzip -q /usr/quber/github_modules_ops.pyz -d /usr/quber/github_modules_ops
          python /usr/quber/github_modules_ops prepare-data
          python /usr/quber/module_cli ${{ inputs.module_command }} --context_path rt/job_data/context.yaml
          python /usr/quber/github_modules_ops store-data

      - name: Upload files
        id: upload-files
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.job_id }}
          path: rt/stored_data